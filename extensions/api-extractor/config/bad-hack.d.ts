import { BitId } from 'bit-bin/dist/bit-id';
import { BuildContext } from '@teambit/builder';
import { BuildTask } from '@teambit/builder';
import { BuiltTaskResult } from '@teambit/builder';
import { Capsule } from '@teambit/isolator';
import { CLIMain } from '@teambit/cli';
import { Component } from '@teambit/component';
import { ConcreteService } from '@teambit/environments';
import { EnvsMain } from '@teambit/environments';
import { LoggerMain } from '@teambit/logger';
import { SerializableResults } from '@teambit/workspace';
import { Workspace } from '@teambit/workspace';

declare type BuildResult = {
  component: string;
  buildResults: string[] | null | undefined;
};

declare interface Compiler extends ConcreteService {
  /**
   * transpile a single file. this being used during development and get saved into the workspace
   */
  transpileFile: (fileContent: string, options: TranspileOpts) => TranspileOutput;
  /**
   * compile components inside isolated capsules. this being used during tag for the release.
   * meaning, the final package of the component has the dists generated by this method.
   */
  build(context: BuildContext): Promise<BuiltTaskResult>;
  /**
   * returns the relative path of the dist directory inside the capsule. e.g. "dist".
   */
  getDistDir(): string;
  /**
   * given a source file, return its parallel in the dists. e.g. "index.ts" => "dist/index.js"
   * both, the return path and the given path are relative paths.
   */
  getDistPathBySrcPath(srcPath: string): string;
  /**
   * only supported files matching get compiled. others, are copied to the dist dir.
   */
  isFileSupported(filePath: string): boolean;
  /**
   * implement if some files generated by the compiler are not needed for the package
   */
  getNpmIgnoreEntries?(): string[];
}

export declare class CompilerMain {
  private workspaceCompiler;
  readonly task: CompilerTask;
  constructor(workspaceCompiler: WorkspaceCompiler, task: CompilerTask);
  compileOnWorkspace(
    componentsIds: string[] | BitId[], // when empty, it compiles all
    options: {
      noCache?: boolean;
      verbose?: boolean;
    }
  ): Promise<
    {
      component: string;
      buildResults: string[];
    }[]
  >;
  static provider([cli, workspace, envs, loggerMain]: [CLIMain, Workspace, EnvsMain, LoggerMain]): Promise<
    CompilerMain
  >;
  // static runtime: import("@teambit/harmony").RuntimeDefinition;
  // static dependencies: import("@teambit/harmony").Aspect[];
}

/**
 * compiler build task. Allows to compile components during component build.
 */
declare class CompilerTask implements BuildTask {
  readonly id: string;
  readonly description = 'compile components';
  constructor(id: string);
  execute(context: BuildContext): Promise<BuiltTaskResult>;
  copyNonSupportedFiles(
    capsule: Capsule,
    compiler: Compiler
  ): Promise<{
    // id: import("@teambit/component").ComponentID;
    errors: any[];
  }>;
}

declare type LegacyCompilerOptions = {
  noCache?: boolean;
  verbose?: boolean;
  dontPrintEnvMsg?: boolean;
};

declare type TranspileOpts = {
  componentDir: string;
  filePath: string;
};

declare type TranspileOutput =
  | {
      outputText: string;
      outputPath: string;
    }[]
  | null;

declare class WorkspaceCompiler {
  private workspace;
  private envs;
  constructor(workspace: Workspace, envs: EnvsMain);
  onComponentChange(component: Component): Promise<SerializableResults>;
  compileComponents(
    componentsIds: string[] | BitId[], // when empty, it compiles all
    options: LegacyCompilerOptions
  ): Promise<BuildResult[]>;
  private compileWithLegacyCompilers;
  private resolveIds;
}

export {};
